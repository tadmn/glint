
namespace tb {

graph FanOut(int numOut) {
    input stream float in;
    output stream float<numOut> out;
    connection float<numOut>(in) -> out;
}

graph AveragedSum(int numIn) {
    input stream float<numIn> in;
    output stream float out;

    let gain = 1.f / sqrt(float(numIn));

    float averagedSum(float<numIn> a) {
        return sum(a) * gain;
    }

    connection averagedSum(in) -> out;
}

processor HouseholderMatrixMixer(int size) {
    input stream float<size> in;
    output stream float<size> out;

    let normFactor = -2.f / float(size);

    void main() {
        loop {
            var v = in;

            float sum;
            for (clamp<size> i)
                sum += v[i];

            sum *= normFactor;
            
            for (clamp<size> i)
                v[i] += sum;

            out <- v;

            advance();
        }
    }
}

processor HadamardMatrixMixer(int size) {
    input stream float<size> in;
    output stream float<size> out;

    let normFactor = sqrt(1.f / float(size));

    void main() {
        loop {
            var data = in;

            // Iterate through all levels of the transform
            // Start with blocks of size 2, then 4, 8, etc.
            for (int blockSize = 2; blockSize <= size; blockSize *= 2) {
                let halfBlock = blockSize / 2;

                // Process all blocks of current size
                for (int blockStart = 0; blockStart < size; blockStart += blockSize) {
                    // Combine the two halves of this block
                    for (int i = 0; i < halfBlock; ++i) {
                        let a = data.at(blockStart + i);
                        let b = data.at(blockStart + i + halfBlock);
                        data.at(blockStart + i) = (a + b);
                        data.at(blockStart + i + halfBlock) = (a - b);
                    }
                }
            }

            for (clamp<size> c)
                data[c] *= normFactor;

            out <- data;

            advance();
        }
    }
}

}

namespace glint {

processor MultiChannelDelay(int numChannels, float maxDelayMilliSeconds) {
    input stream float<numChannels> in;
    output stream float<numChannels> out;

    let maxDelay = int(maxDelayMilliSeconds * 0.001 * processor.frequency);

    struct Delay {
        void setDelay(int size) {
            this.write = this.read + wrap<maxDelay>(size);
        }

        float process(float in) {
            let v = this.buffer[this.read++];
            this.buffer[this.write++] = in;
            return v;
        }

        wrap<maxDelay> read;
        wrap<maxDelay> write;
        float[maxDelay] buffer;
    }

    Delay[numChannels] delays;

    void init() {
        std::random::RNG rng;
        rng.seed(processor.id);
        for (clamp<numChannels> c) {
            let min = maxDelay * c / numChannels;
            let max = maxDelay * (c + 1) / numChannels;
            let delaySize = int(min + rng.getUnipolar() * (max - min));
            delays[c].setDelay(delaySize);
        }
    }

    void main() {
        loop {
            float<numChannels> v;
            for (clamp<numChannels> c)
                v[c] = delays[c].process(in[c]);

            out <- v;
            advance();
        }
    }
}

processor Invert(int numChannels) {
    input stream float<numChannels> in;
    output stream float<numChannels> out;

    float[numChannels] gains;

    void init() {
        std::random::RNG rng;
        rng.seed(processor.id);
        for (clamp<numChannels> c)
            gains[c] = rng.getUnipolar() > 0.5f ? 1.f : -1.f;
    }

    void main() {
        loop {
            float<numChannels> v;
            for (clamp<numChannels> c)
                v[c] = in[c] * gains[c];

            out <- v;
            advance();
        }
    }
}

graph Diffuser(int numChannels, float maxDiffuserDelay) {
    input stream float<numChannels> in;
    output stream float<numChannels> out;

    node {
        delay = MultiChannelDelay(numChannels, maxDiffuserDelay);
        invert = Invert(numChannels);
        matrix = tb::HadamardMatrixMixer(numChannels);
    }

    connection {
        in -> delay -> matrix -> invert -> out;
    }
}

graph DiffuserChain(int numChannels) {
    input stream float<numChannels> in;
    output stream float<numChannels> out;

    node {
        d1 = Diffuser(numChannels, 48);
        d2 = Diffuser(numChannels, 96);
        d3 = Diffuser(numChannels, 192);
        d4 = Diffuser(numChannels, 384);
        d5 = Diffuser(numChannels, 768);
    }

    connection {
        in -> d1 -> d2 -> d3 -> d4 -> d5 -> out;
    }
}

graph FeedbackChain(int numChannels) {
    input stream float<numChannels> in;
    output stream float<numChannels> out;

    node {
        delay = MultiChannelDelay(numChannels, 150.f);
        matrix = tb::HouseholderMatrixMixer(numChannels);
        gain = std::levels::ConstantGain(float<numChannels>, 0.85f);
    }

    connection {
        in -> delay.in;
        delay.out -> [1] -> gain -> matrix -> delay.in;
        delay.out -> out;
    }
}

graph Reverb {
    input stream float in;
    output stream float out;

    let numChannels = 16;

    node {
        fanOut = tb::FanOut(numChannels);
        diffuser = DiffuserChain(numChannels);
        feedback = FeedbackChain(numChannels);
        sum = tb::AveragedSum(numChannels);
    }

    connection in -> fanOut -> diffuser -> feedback -> sum -> out;
}

graph glint [[ main ]] {
    input stream float<2> in;
    output stream float<2> out;

    input value float mixAmount [[ name: "Mix", unit: "%", min: 0, max: 100, init: 20 ]];
    input gain.volume;

    node {
        reverb = Reverb[2];
        reverbGain = std::levels::ConstantGain(float<2>, 0.6f);
        mix = std::mixers::Interpolator(float<2>, 100.f);
        gain = std::levels::SmoothedGain(float<2>);
    }

    connection {
        mixAmount -> mix.mix;

        in -> mix.in1;

        float(in[0]) -> reverb[0].in;
        float(in[1]) -> reverb[1].in;

        float<2>(reverb[0].out, reverb[1].out) -> reverbGain -> mix.in2;
        
        mix.out -> gain.in;
        gain.out -> out;
    }
}

}